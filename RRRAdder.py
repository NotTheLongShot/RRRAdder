#!/usr/bin/env python3

"""
RRRAdder - a script to add Rearm/Refuel/Repair/Healing vehicles to airfields in IL-2 Sturmovik: Great Battles.

@version: 0.1
@author: NotTheLongShot
"""

import argparse
import datetime
import hashlib
import json
import os
import re
import sys
from pathlib import Path
from typing import Sequence, Tuple, List, NoReturn


Vector = Tuple[float, float, float]


class Vehicle:
    """ A class to store and write the relevant particulars of Vehicle elements and their linked entries. """

    def __init__(
            self,
            name: str,
            vehicle_type: str,
            country: int,
            location_tuple: Vector,
            rotation_tuple: Vector,
            ) -> NoReturn:

        self.name = name
        self.vehicle_type = vehicle_type
        self.country = country
        self.xPos, self.yPos, self.zPos = location_tuple
        self.xOri, self.yOri, self.zOri = rotation_tuple

    def _get_vehicle_paths(self) -> Tuple[str, str]:
        lua, model = r"LuaScripts\WorldObjects\vehicles\{name}.txt", r"graphics\vehicles\{subdir}\{name}.mgm"

        vehicle_lookup = {
            "opel-blitz-ammo": "opel",
            "fake_vehicle": "fake_vehicle",
            "benzlkw-ammo": "benzlkw",
            "benzlkw": "benzlkw",
            "leyland3tonraf-ammo": "leyland3tonraf",
            "leyland3tonraf": "leyland3tonraf",
        }

        return lua.format(name=self.vehicle_type), \
               model.format(subdir=vehicle_lookup[self.vehicle_type],
                            name=self.vehicle_type)  # deliberately raise KeyError here if fails

    def to_text(self,
                index: int = -1,
                maintenanceRadius: int = 50,
                repairFriendlies: bool = False,
                rehealFriendlies: bool = False,
                rearmFriendlies: bool = False,
                refuelFriendlies: bool = False,
                repairTime: float = 0.,
                rehealTime: float = 0.,
                rearmTime: float = 0.,
                refuelTime: float = 0.,
                **overrides) -> str:

        lua, model = self._get_vehicle_paths()
        overrides = {str(k).lower(): i for k, i in overrides.items()}

        trid = index + 1

        if int(repairTime) == repairTime: repairTime = int(repairTime)
        if int(rehealTime) == rehealTime: rehealTime = int(rehealTime)
        if int(rearmTime) == rearmTime: rearmTime = int(rearmTime)
        if int(refuelTime) == refuelTime: refuelTime = int(refuelTime)

        return rf"""Vehicle
{{
  Name = "{overrides.get('name', self.name)}";
  Index = {index};
  LinkTrId = {trid};
  XPos = {overrides.get('xpos', self.xPos):.3f};
  YPos = {overrides.get('ypos', self.yPos):.3f};
  ZPos = {overrides.get('zpos', self.zPos):.3f};
  XOri = {overrides.get('xori', self.xOri):.2f};
  YOri = {overrides.get('yori', self.yOri):.2f};
  ZOri = {overrides.get('zori', self.zOri):.2f};
  Script = "{lua}";
  Model = "{model}";
  Desc = "Added by RRRAdder";
  Country = {overrides.get('country', self.country)};
  NumberInFormation = 0;
  Vulnerable = {overrides.get('vulnerable', 1)};
  Engageable = {overrides.get('engageable', 1)};
  LimitAmmo = 1;
  AILevel = 1;
  DamageReport = 50;
  DamageThreshold = 1;
  DeleteAfterDeath = 1;
  CoopStart = 0;
  Spotter = -1;
  BeaconChannel = 0;
  Callsign = 0;
  PayloadId = 0;
  WMMask = 1;
  Fuel = 1;
  Callnum = 0;
  Skin = "";
  RepairFriendlies = {int(repairFriendlies)};
  RehealFriendlies = {int(rehealFriendlies)};
  RearmFriendlies = {int(rearmFriendlies)};
  RefuelFriendlies = {int(refuelFriendlies)};
  RepairTime = {repairTime};
  RehealTime = {rehealTime};
  RearmTime = {rearmTime};
  RefuelTime = {refuelTime};
  MaintenanceRadius = {maintenanceRadius};
  TCode = "%20%20%20%20";
  TCodeColor = "0000";
}}



MCU_TR_Entity
{{
  Index = {trid};
  Name = "{overrides.get('name', self.name)} entity";
  Desc = "";
  Targets = [];
  Objects = [];
  XPos = {overrides.get('xpos', self.xPos):.3f};
  YPos = {overrides.get('ypos', self.yPos):.3f};
  ZPos = {overrides.get('zpos', self.zPos):.3f};
  XOri = 0.00;
  YOri = 0.00;
  ZOri = 0.00;
  Enabled = 1;
  MisObjID = {index};
}}



"""


def parse_args(args: List[str] or None = None) -> argparse.Namespace:
    """ Parse arguments, read the config file, and shove that into the argparse Namespace too. """

    parser = argparse.ArgumentParser(description="Add refuel/rearm/repair/heal vehicles to airfields in campaigns "
                                     "generated by Pat Wilson's Campaign Generator for IL-2 Sturmovik: Flying Circus.")

    parser.add_argument("-c", "--config",
                        type=str,
                        default="config.json",
                        help="The config file to use. If none is given the script will automatically try to read "
                             "config.json from the local directory."
                        )
    parser.add_argument("-m", "--mission",
                        type=str,
                        default="",
                        help="The mission file to use. If none is given but a config file with a Mission/PWCG directory"
                        " and a campaign name is given or findable, the script will find the latest mission in that"
                        " campaign.")

    if args is not None:
        args = parser.parse_args(args)
    else:
        args = parser.parse_args()

    print(f"INFO: Reading {args.config}...")
    with open(args.config, 'r') as f:
        config = json.load(f)

    for c, v in config.items():
        if c not in args.__dict__.keys():
            args.__dict__[c] = v

    print("INFO: Proceeding with the following settings:")
    d = "    "
    for key in ("pwcg_missions_dir", "campaign_name", "use_only_friendly", "run_missionresaver", "maintenanceRadius",
                "repair", "heal", "rearm", "refuel", "repairTime", "healTime", "rearmTime", "refuelTime"):
        print(d, key.ljust(25, " "), args.__dict__[key], sep="")
    print(d, "airfields:", sep="")
    for i, f in enumerate(args.airfields):
        end = "\n" if i+1 == len(args.airfields) else ",\n"
        print(" "*29, f, sep="", end=end)
    print(d, "overrides:", sep="")
    for k, v in args.overrides.items():
        print(" "*16, k.ljust(9, " "), d, v, sep="")

    return args


def get_highest_index(text: str) -> int:
    """ Find the highest index number used in the text of the .mission file. """

    ids = re.findall("Index = (\d+);", text)
    return max(map(int, ids))


def get_latest_campaign_mission(directory: str, campaign: str) -> Path:
    """ Get the mission file in the directory that matches the campaign string
    and has the latest datestamp in its name. """

    def datetime_key(file: Path or str) -> int:
        """ Return the number of days since the beginning of WW1. """

        file_date_parts = re.findall("(\d{4})-(\d{2})-(\d{2})", str(file))

        if file_date_parts:
            # int-ify the file date parts and unpack them into a datetime.date(year, month, day)
            file_date = datetime.date(*map(int, file_date_parts[0]))

            since_war_start = file_date - datetime.date(1914, 7, 28)
            return since_war_start.days
        else:
            return -1  # this will put it at the front of the ascending list (assuming there are no dates before WW1)

    missions_files = list(Path(directory).glob(f"{campaign} *.mission"))

    if missions_files:
        missions_files.sort(key=datetime_key)
        return missions_files[-1]

    else:
        raise FileNotFoundError("Are you sure your campaign name is set exactly right?")


def euclidean_distance(vector1: Vector, vector2: Vector) -> float:
    """ Find the euclidean distance between two points, defined as
    dist = sqrt( (v1d1 - v2d1)**2 + (v1d2 - v2d2)**2 + (v1d3 - v2d3)**2 ... )"""

    from math import sqrt

    assert len(vector1) == len(vector2)

    distances_squared = []

    for v1, v2 in zip(vector1, vector2):
        distances_squared.append((v2 - v1) ** 2)

    return sqrt(sum(distances_squared))


def get_mission_element(element: str, mission_text: str) -> List[dict]:
    """ Find an element in the mission text, based on its header (e.g. Vehicle, Airfield, etc.) """

    query = f"\s{element}\s+\{{([\w\W]*?)\}}"
    elements = re.findall(query, mission_text)
    element_dicts = []

    for e in elements:
        pts = [l for l in e.split("\n") if " = " in l]
        element_dicts.append({v.split(" = ")[0].strip(): v.split(" = ")[1].strip(";").replace('"', '') for v in pts})

    return element_dicts


def get_akaks(mission_text: str) -> List[dict]:
    """ Find AA guns, i.e. Vehicle elements with "AA" in the name. """

    aa_guns = ("flak77cml27", "hotchkissmle14-aa", "mg08-aa", "qf13pdr6cwt", "thorny13pdr-aa")

    vehicles = get_mission_element("Vehicle", mission_text)
    return [v for v in vehicles if any(aa_gun in v["Script"] for aa_gun in aa_guns)]


def get_location_tuple_from_element(e: dict) -> Vector:
    """ Take a dictionary with the keys XPos, YPos, ZPos, and make a Tuple[float, float, float] out of it. Missing keys
    are read as 0.0 """

    return tuple(map(float, (e.get("XPos", 0.), e.get("YPos", 0.), e.get("ZPos", 0.))))


def get_active_airfields(mission_text: str) -> List[str]:
    """ Find AA gun vehicles and filter airfields that are less than a kilometer from the nearest AA gun - a heuristic
    for active airfields within the PWCG mission box. """

    aa_coords = [get_location_tuple_from_element(aa) for aa in get_akaks(mission_text)]

    airfields = {af["Name"].replace("Fake ", ""): get_location_tuple_from_element(af)
                 for af in get_mission_element("Airfield", mission_text)}

    min_dist_to_aa = {af_name: min(euclidean_distance(af_coord, aa_coord) for aa_coord in aa_coords)
                      for af_name, af_coord in airfields.items()}

    return [af_name for af_name, min_dist in min_dist_to_aa.items() if min_dist <= 1000.]


def get_closest_airfield(player_coords: Vector, vehicles: dict) -> str:
    """Find the closest vehicle to the set of coordinates given."""

    euclid_dists = {k: euclidean_distance(player_coords, v[0]["location_tuple"]) for k, v in vehicles.items()}
    closest = sorted(list(euclid_dists.keys()),
                  key=lambda x: euclid_dists[x])[0]
    print(f"INFO: Found home airfield: {closest}")
    if euclid_dists[closest] > 1000:
        print(f"WARNING: Home airfield at {closest} is more than 1km away from spawn point.")

    return closest


def munge_airfields(airfields: List[str], mission_text: str) -> Tuple[List[str], Vector]:
    """ Do an untidy collection of stuff to get the airfields list in order.
    1. Replace "home" with the nearest airfield to the player vehicle spawn.
    2. Replace "active_in_mission_box" with active populated airfields as guessed by having nearby AA guns.
    3. Replace the airfield names used by PWCG (e.g. Cambrai North) with the airfield names given by the ingame map
       (e.g. Epinoy).
    """

    # FIND HOME FIELD
    if "home" in airfields:
        player_coords = get_location_tuple_from_element(get_player_entry(mission_text))
        airfields = [af for af in airfields if af != "home"]
    else:
        player_coords = None

    # FIND ACTIVE IN MISSION AREA:
    if "active_in_mission_box" in airfields:
        new_airfields = get_active_airfields(mission_text)
        airfields += new_airfields
        airfields = [af for af in airfields if af != "active_in_mission_box"]
        print(f"INFO: {len(new_airfields)} populated airfields found.")

    # CHECK VARIANT NAMES AGAINST NAME DATABASE
    filtered_airfields = []
    with open(r"data\airfield_names.json", "r") as f:
        names = json.load(f)

    for airfield in airfields:
        filtered_airfields.append(
            names.get(airfield, airfield)
        )

    return filtered_airfields, player_coords


def load_vehicle_json() -> List[Vehicle]:
    """ Load the vehicle JSON file and convert rotation_y into rotation_tuple (rotation x and z are always 0). """

    with open(r"data\vehicle_locations.json", "r") as f:
        vehicles = json.load(f)

    for k, vehls in vehicles.items():
        for i, v in enumerate(vehls):
            if v.get("rotation_y", False):
                vehicles[k][i]["rotation_tuple"] = (0., v["rotation_y"], 0.)
                vehicles[k][i].pop("rotation_y")

    return vehicles


def create_vehicles(airfields: List[str], mission_text: str, use_only_friendly: bool = True) -> List[Vehicle]:
    """ Manage the loading of the vehicles; get closest airfield if "home" is in airfield list, filter vehicle objects
    by specified airfield and friendliness. """

    airfields, player_coords = munge_airfields(airfields, mission_text)

    vehicles = load_vehicle_json()

    if player_coords is not None:
        airfields.append(get_closest_airfield(player_coords, vehicles))

    if not airfields:
        print("INFO: No airfields specified: using all.")
        airfields = list(vehicles.keys())

    vehicles = [Vehicle(**vehicle_dict) for airfield, vehicle_list in vehicles.items() for vehicle_dict in vehicle_list
                if airfield in airfields]

    if use_only_friendly:
        player_country_prefix = str(get_player_entry(mission_text)["Country"])[0]
        vehicles = [v for v in vehicles if str(v.country)[0] == player_country_prefix]

    return vehicles


def get_player_entry(mission_text: str) -> dict:
    """ Finds the player Plane in the mission file, denoted by "AILevel = 0"
    - n.b. this may fail in coop mission files. """

    player = [p for p in get_mission_element("Plane", mission_text) if p["AILevel"] == "0"][0]

    return player


def create_new_mission_text(
        vehicles: Sequence[Vehicle],
        starting_index: int,
        maintenanceRadius: int = 50,
        repair: bool = False,
        heal: bool = False,
        rearm: bool = False,
        refuel: bool = False,
        repairTime: float = 0.,
        healTime: float = 0.,
        rearmTime: float = 0.,
        refuelTime: float = 0.,
        **overrides
        ) -> str:
    """ Manage the indices, invoke the Vehicle.to_text method on a list of vehicles with the right parameters,
    and concatenate the results into one long string. """

    string = ""
    running_index = starting_index

    for v in vehicles:
        string += v.to_text(
            index=running_index,
            maintenanceRadius=maintenanceRadius,
            repairFriendlies=repair,
            rehealFriendlies=heal,
            rearmFriendlies=rearm,
            refuelFriendlies=refuel,
            repairTime=repairTime,
            rehealTime=healTime,
            rearmTime=rearmTime,
            refuelTime=refuelTime,
            **overrides
        )
        running_index += 2

    return string


def invoke_MissionResaver(mission_path: Path or str, pwcg_missions_dir: Path or str, run: bool = True) -> NoReturn:
    """Construct the MissionResaver command and run it as a subprocess unless told otherwise."""

    # basepath = Path(os.getcwd()).parent
    basepath = Path(pwcg_missions_dir).resolve().parent.parent.parent

    # if you are having problems with the program finding mission resaver, replace line 404 with:
    # missionresaver_path = Path(r"C:\path\to\your\MissionResaver.exe")  # keep the Path(r", ") & only 1 set of quotes!
    missionresaver_path = basepath.joinpath("bin/resaver/MissionResaver.exe")
    data_dir = basepath.joinpath("data")

    mission_path = Path(mission_path).resolve()

    if missionresaver_path.exists():
        command = f"\"{missionresaver_path}\" -d \"{data_dir}\" -f \"{mission_path}\""
        if run:
            print(f"$ {command}")
            import subprocess
            subprocess.run(command)
        else:
            print(
                "INFO: To reconstruct the mission binary (.msnbin) file, run the following command in a "
                "Command Prompt:",
                command,
                sep="\n"
            )
    else:
        print(f"ERROR: MissionResaver.exe not found in {missionresaver_path.parent}")


def main() -> NoReturn:

    # CHANGE working directory TO RRR home directory
    os.chdir(sys.path[0])

    # READ ARGUMENTS AND CONFIG FILE
    args = parse_args()
    
    # GET MISSION PATH
    if not args.mission:
        args.mission = get_latest_campaign_mission(args.pwcg_missions_dir, args.campaign_name)
        print(f"INFO: Found {args.campaign_name} campaign mission: {args.mission.name}")
    else:
        args.mission = Path(args.mission)
        print(f"INFO: Using mission: {args.mission}")
        if args.mission.suffix not in (".mission", ".Mission"):
            print("WARNING: Specified file does not end with .mission. RRRAdder changes to files not in the .mission "
                  "format will probably fail.")

    # GET MISSION TEXT
    with open(args.mission, 'r') as f:
        mission_text = f.read()
    if "RRRAdder" in mission_text:
        print("INFO: Mission file has already been modified by the RRR Adder.")
        print("QUITTING...")
        quit(0)

    # BACKUP ORIGINAL
    msnbackup = args.mission.with_suffix(".msnbackup")
    if args.backup_original:
        with open(msnbackup, "w") as f:
            f.write(mission_text)

    # GET STARTING INDEX
    highest_index = get_highest_index(mission_text)

    # GET RRR VEHICLES
    vehicles = create_vehicles(args.airfields, mission_text, use_only_friendly=args.use_only_friendly)

    # CREATE RRR VEHICLE TEXT TO INSERT
    new_mission_text = create_new_mission_text(
        vehicles,
        highest_index+1,
        maintenanceRadius=args.maintenanceRadius,
        repair=args.repair,
        heal=args.heal,
        rearm=args.rearm,
        refuel=args.refuel,
        repairTime=args.repairTime,
        healTime=args.healTime,
        rearmTime=args.rearmTime,
        refuelTime=args.refuelTime,
        **args.overrides,
        )

    # INSERT RRR VEHICLE TEXT INTO MISSION TEXT
    mission_text = mission_text.strip("\n")
    if mission_text.endswith("# end of file"):
        endswith = True
        mission_text = mission_text.replace("# end of file", "\n")
    else:
        endswith = False

    mission_text += new_mission_text

    if endswith:
        mission_text = mission_text[:-1] + "# end of file"

    # WRITE MODIFIED MISSION TEXT TO ORIGINAL FILE
    print("INFO: Modifying .mission file...", end=" ")
    with open(args.mission, 'w') as f:
        f.write(mission_text)
    print("done.")

    # INVOKE MISSIONRESAVER.EXE
    if args.run_missionresaver:
        print("INFO: Rewriting .msnbin file... (this takes a while)")
    invoke_MissionResaver(args.mission, args.pwcg_missions_dir, run=args.run_missionresaver)

    if b"RRRAdder" in args.mission.with_suffix(".msnbin").read_bytes():
        print("INFO: RRRAdder done.")
    else:
        print("ERROR: Process incomplete: MissionResaver.exe seems to have failed to create a new .msnbin file.")
        if args.backup_original:
            msnbackup.replace(args.mission)
            print("INFO: The original mission has been restored from the backup.")

    input("INPUT: Press ENTER to finish.")

if __name__ == "__main__":
    main()